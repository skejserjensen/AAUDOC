module File
( Document(..)
, Job (..)
, buildJobList
) where

import Data.List (delete)
import Data.Char (isSpace)
import Control.Monad (forM)
import System.Exit (ExitCode(..), ExitCode)
import System.Process (readProcessWithExitCode)
import System.FilePath ((</>), takeExtension, dropExtension)
import System.Directory (doesDirectoryExist, getDirectoryContents, removeFile)

-- Data Types
data Document = Document { path :: String
                         , name :: String
                         , folderPath :: String
                         } deriving Show

data Job = Job { operation :: String
               , function :: Document -> IO (ExitCode, String, String)
               }

-- Public Functions --
buildJobList :: Document -> IO [Job]
buildJobList doc = readHeader (path doc) >>= return . parseHeader

-- Header Parser --
readHeader :: String -> IO [String]
readHeader docPath = readFile docPath >>= return . takeHeader
    where takeHeader = takeWhile (/= "") . rstripWhitespace . lines

parseHeader :: [String] -> [Job]
parseHeader headerLines = reverse $ foldl buildJobs [] headerLines
    where buildJobs = (\acc line -> (buildJob $ words $ line) : acc)


-- Job Creation --
buildJob :: [String] -> Job
buildJob ["%command", command] = Job ("Command: " ++ command) (commandJob command)
buildJob ("%link":inputPath:outputPath:[]) = Job ("Linkning: " ++ inputPath ++ " => " ++ outputPath)
                                                (linkJob inputPath outputPath)
buildJob ("%clean":suffixes) = Job ("Cleaning: " ++ (show suffixes)) (cleanJob suffixes)
buildJob list = error $ "BuildJob: unknown operation in header \"" ++ show list ++ "\""

-- Job Functions --
linkJob :: String -> String -> Document -> IO (ExitCode, String, String)
linkJob inputPath outputPath _ = do
                    -- Searches the specified folder for tex files and a bibliography
                    textFiles <- (getFilesWithSuffixRecursive inputPath [".bib", ".tex"])
                    let textFilesWithoutOutputFile = delete outputPath textFiles
                    let outputFileLines = map formatIndexLines textFilesWithoutOutputFile
                    -- Prepares the output file and a curried append function with its name
                    let outputAppend = appendFile outputPath
                    writeFile outputPath "%Index automatically generated by AAUDOC-Haskell, \
                        \changes done to the file will be overwritten upon next compilation"
                    outputAppend "\n\\begin{document}"
                    mapM_ (\line ->  outputAppend $ '\n' : line) outputFileLines
                    outputAppend "\n\\end{document}"
                    -- The return of (ExitSuccess, "", "") is added for a uniform interface between all jobs
                    return (ExitSuccess, "", "")

commandJob :: String -> Document -> IO (ExitCode, String, String) 
commandJob command doc = readProcessWithExitCode command [name doc] []

cleanJob :: [String] -> Document -> IO (ExitCode, String, String)
-- The return of (ExitSuccess, "", "") is added for a uniform interface between all jobs
cleanJob suffixToDelete doc = mapM_  prependPath suffixToDelete >> return (ExitSuccess, "", "")
    where prependPath = (\suffix -> removeFile $ (name doc) ++ "." ++ suffix) 


-- Helper Functions --
rstripWhitespace :: [String] -> [String]
rstripWhitespace listOfStrings = map rstrip listOfStrings 
    where  rstrip = reverse . dropWhile isSpace . reverse

getFilesWithSuffixRecursive :: String -> [String] -> IO [String]
getFilesWithSuffixRecursive directoryPath suffix = files >>= filterWithSuffix
    where files = getContentsRecursive directoryPath
          filterWithSuffix = return . filter (\file -> takeExtension file `elem` suffix)

-- Published in Real World Haskell Chapter 9 under the (CC BY-NC 3.0) license
getContentsRecursive :: String -> IO [String]
getContentsRecursive topdir = do
  directoryContents <- getDirectoryContents topdir
  let properNames = filter (`notElem` [".", ".."]) directoryContents 
  paths <- forM properNames $ \directoryElement -> do
    let elementPath = topdir </> directoryElement 
    isDirectory <- doesDirectoryExist elementPath
    if isDirectory
      then getContentsRecursive elementPath
      else return [elementPath]
  return $ concat paths

formatIndexLines :: String -> String
formatIndexLines line
    | (takeExtension line) == ".tex" = "\\input{" ++ (dropExtension line) ++ "}"
    | (takeExtension line) == ".bib" = "\\bibliography{" ++ (dropExtension line) ++ "}"
    | True = error $ "LinkJob: unknown filetype passed to index fomatter \"" ++ line ++ "\""

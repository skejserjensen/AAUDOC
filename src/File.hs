module File
( Document(..)
, Job (..)
, buildJobList
) where

import Data.List (delete)
import Data.Char (isSpace)
import Control.Monad (forM)
import System.Process (readProcess)
import System.FilePath ((</>), takeExtension, dropExtension)
import System.Directory (doesDirectoryExist, getDirectoryContents, removeFile)

-- Data Types
data Document = Document { path :: String
                         , name :: String
                         , folderPath :: String
                         } deriving Show

data Job = Job { operation :: String
               , function :: Document -> IO String
               }

-- Public Functions --
buildJobList :: Document -> IO [Job]
buildJobList doc = readHeader (path doc) >>= return . parseHeader

-- Header Parser --
readHeader :: String -> IO [String]
readHeader docPath = readFile docPath >>= return . takeHeader
    where takeHeader = takeWhile (/= "") . rstripWhitespace . lines

parseHeader :: [String] -> [Job]
parseHeader headerLines = reverse $ foldl buildJobs [] headerLines
    where buildJobs = (\acc line -> (buildJob $ words $ line) : acc)


-- Job Creation --
buildJob :: [String] -> Job
buildJob ["%command", command] = Job ("Command: " ++ command) (commandJob command)
buildJob ("%link":inputPath:outputPath:[]) = Job ("Linkning: " ++ inputPath ++ " => " ++ outputPath)
                                                (linkJob inputPath outputPath)
buildJob ("%clean":suffixes) = Job ("Cleaning: " ++ (show suffixes)) (cleanJob suffixes)
buildJob list = error $ "BuildJob: unknown operation in header: " ++ show list

-- Job Functions --
linkJob :: String -> String -> Document -> IO String
linkJob inputPath outputPath doc = do
                    -- Searches the specified folder for tex files and a bibliography
                    textFiles <- (getFilesWithSuffixRecursive inputPath [".bib", ".tex"])
                    let textFilesWithoutOutputFile = delete outputPath textFiles
                    let outputFileLines = map formatIndexLines textFilesWithoutOutputFile
                    -- Prepares the output file and a curried append function with its name
                    let outputAppend = appendFile outputPath
                    writeFile outputPath "%Index automatically generated by AAUDOC-Haskell, \
                        \changes done to the file will be overwritten upon next compilation"
                    outputAppend "\n\\begin{document}"
                    mapM (\line ->  outputAppend $ '\n' : line) outputFileLines
                    outputAppend "\n\\end{document}"
                    -- We force a return of IO String for all jobs to have the same interface
                    return "" 

commandJob :: String -> Document -> IO String
commandJob command doc = readProcess command [name doc] []

cleanJob :: [String] -> Document -> IO String 
-- The return of "" is added for a uniform interface between all jobs
cleanJob suffixToDelete doc = mapM_  prependPath suffixToDelete >> return ""
    where prependPath = (\elem -> removeFile $ (name doc) ++ "." ++ elem) 


-- Helper Functions --
rstripWhitespace :: [String] -> [String]
rstripWhitespace listOfStrings = map rstrip listOfStrings 
    where  rstrip = reverse . dropWhile isSpace . reverse

getFilesWithSuffixRecursive :: String -> [String] -> IO [String]
getFilesWithSuffixRecursive directoryPath suffix = files >>= filterWithSuffix
    where files = getContentsRecursive directoryPath
          filterWithSuffix = return . filter (\file -> takeExtension file `elem` suffix)

-- Published in Real World Haskell Chapter 9 under the (CC BY-NC 3.0) license
getContentsRecursive :: String -> IO [String]
getContentsRecursive topdir = do
  names <- getDirectoryContents topdir
  let properNames = filter (`notElem` [".", ".."]) names
  paths <- forM properNames $ \name -> do
    let path = topdir </> name
    isDirectory <- doesDirectoryExist path
    if isDirectory
      then getContentsRecursive path
      else return [path]
  return $ concat paths

formatIndexLines :: String -> String
formatIndexLines line
    | (takeExtension line) == ".tex" = "\\input{" ++ (dropExtension line) ++ "}"
    | (takeExtension line) == ".bib" = "\\bibliography{" ++ (dropExtension line) ++ "}"

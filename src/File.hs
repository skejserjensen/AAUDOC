module File
( Document (..)
, Job (..)
, buildJobList
) where

import Data.Char (isSpace)
import Data.List (delete, sort)
import Control.Monad (forM, liftM, (>=>))
import Control.Exception (throwIO, catch)
import System.Exit (ExitCode (..), ExitCode)
import System.IO.Error (isDoesNotExistError)
import System.Process (readProcessWithExitCode)
import System.FilePath ((</>), takeExtension, dropExtension)
import System.Directory (doesDirectoryExist, getDirectoryContents, removeFile)

-- Data Types --
data Document = Document { path :: String
                         , name :: String
                         , folderPath :: String
                         } deriving Show

data Job = Job { operation :: String
               , function :: Document -> IO (ExitCode, String, String)
               }


-- Public Functions --
buildJobList :: Document -> IO [Job]
buildJobList doc = liftM parseHeader $ readHeader $ path doc


-- Header Parser --
readHeader :: String -> IO [String]
readHeader docPath = liftM takeHeader $ readFile docPath
    where takeHeader = takeWhile (/= "") . rstripWhitespace . lines

parseHeader :: [String] -> [Job]
parseHeader headerLines = reverse $ foldl buildJobs [] headerLines
    where buildJobs acc line = buildJob (words line) : acc


-- Job Creation --
buildJob :: [String] -> Job
buildJob ["%command", command] = Job ("Command: " ++ command) (commandJob command >=> addJobOutputParser command)
buildJob ("%link" : inputPath : outputPath : []) = Job ("Linkning: " ++ inputPath ++ " => " ++ outputPath)
                                                (linkJob inputPath outputPath)
buildJob ("%clean" : suffixList) = Job ("Cleaning: " ++ show suffixes) (cleanJob suffixes)
    where suffixes = if null suffixList then ["aux", "bbl", "blg", "idx", "log", "out"] else suffixList
buildJob list = error $ "BuildJob: unknown operation in header \"" ++ show list ++ "\""


-- Job Functions --
linkJob :: String -> String -> Document -> IO (ExitCode, String, String)
linkJob inputPath outputPath _ = do
                    -- Searches the specified folder for tex files and a bibliography
                    textFiles <- getFilesWithSuffixRecursive inputPath [".bib", ".tex"]
                    let textFilesWithoutOutputFile = delete outputPath textFiles
                    let uniformOutputLines = map replaceWindowsPathSeparators textFilesWithoutOutputFile
                    let outputFileLines = map formatIndexLines uniformOutputLines
                    -- Prepares the output file and a curried append function with its name
                    let outputAppend = appendFile outputPath
                    writeFile outputPath "%Index automatically generated by AAUDOC-Haskell, \
                            \changes done to the file will be overwritten upon next compilation"
                    outputAppend "\n\\begin{document}"
                    mapM_ (\ line -> outputAppend $ '\n' : line) outputFileLines
                    outputAppend "\n\\end{document}"
                    -- The return of (ExitSuccess, "", "") is added for a uniform interface between all jobs
                    return (ExitSuccess, "", "")

commandJob :: String -> Document -> IO (ExitCode, String, String)
commandJob command doc = readProcessWithExitCode command [name doc] []

cleanJob :: [String] -> Document -> IO (ExitCode, String, String)
-- The return of (ExitSuccess, "", "") is added for a uniform interface between all jobs
cleanJob suffixToDelete doc = mapM_ prependPath suffixToDelete >> return (ExitSuccess, "", "")
    where prependPath suffix = removeFileIfExists $ name doc ++ "." ++ suffix


-- Job Output Parser Functions --
addJobOutputParser :: String -> (ExitCode, String, String) -> IO (ExitCode, String, String)
addJobOutputParser jobName
            | jobName `elem` ["latex", "pdflatex", "xelatex", "lualatex"] = latexStripNonErrors
            | otherwise = \ (exitCode, stdout, stderr) -> return (exitCode, stdout, stderr)

latexStripNonErrors :: (ExitCode, String, String) -> IO (ExitCode, String, String)
latexStripNonErrors (ExitSuccess, stdout, stderr) = return (ExitSuccess, stdout, stderr)
latexStripNonErrors (exitCode, stdout, stderr) = return (exitCode, stdoutErrors, stderr)
    where stdoutErrors = unlines $ reverse $ takeWhile (not . endsWith "tex)") $ reverse $ lines stdout


-- Helper Functions --
rstripWhitespace :: [String] -> [String]
rstripWhitespace = map $ reverse . dropWhile isSpace . reverse

getFilesWithSuffixRecursive :: String -> [String] -> IO [String]
getFilesWithSuffixRecursive directoryPath suffix = files >>= filterWithSuffix
    where files = getContentsRecursive directoryPath
          filterWithSuffix = return . filter (\ file -> takeExtension file `elem` suffix)

-- Published in Real World Haskell Chapter 9 under the (CC BY-NC 3.0) license
getContentsRecursive :: String -> IO [String]
getContentsRecursive topdir = do
  directoryContents <- getDirectoryContents topdir
  let properNames = filter (`notElem` [".", ".."]) directoryContents
  paths <- forM properNames $ \ directoryElement -> do
    let elementPath = topdir </> directoryElement
    isDirectory <- doesDirectoryExist elementPath
    if isDirectory
      then getContentsRecursive elementPath
      else return [elementPath]
  return $ sort $ concat paths

replaceWindowsPathSeparators :: String -> String
replaceWindowsPathSeparators line = reverse $ foldl replaceSeperator "" line
    where replaceSeperator acc char = if char == '\\' then '/' : acc else char : acc

formatIndexLines :: String -> String
formatIndexLines line
    | takeExtension line == ".tex" = "\\input{" ++ dropExtension line ++ "}"
    | takeExtension line == ".bib" = "\\bibliography{" ++ dropExtension line ++ "}"
    | otherwise = error $ "LinkJob: unknown filetype passed to index fomatter \"" ++ line ++ "\""

endsWith :: Eq a => [a] -> [a] -> Bool
endsWith _ [] = False
endsWith end list = reverse end == take (length end) (reverse list)

removeFileIfExists :: String -> IO ()
removeFileIfExists filePath = removeFile filePath `catch` handleFileNotExists
    where handleFileNotExists exeception
            | isDoesNotExistError exeception = return ()
            | otherwise = throwIO exeception
